import 'package:stack_trace/stack_trace.dart';
import 'utils/isolate_utils.dart' as isolate_utils;
import 'posthog_exception.dart';

class DartExceptionProcessor {
  /// Converts Dart error/exception and stack trace to PostHog exception format
  static Map<String, dynamic> processException({
    required Object error,
    StackTrace? stackTrace,
    Map<String, Object>? properties,
    List<String>? inAppIncludes,
    List<String>? inAppExcludes,
    bool inAppByDefault = true,
    StackTrace Function()? stackTraceProvider, //for testing
  }) {
    // Extract PostHog metadata if error is wrapped in PostHogException
    String mechanismType = 'generic';
    bool handled = true;
    Object currentError = error;

    if (error is PostHogException) {
      handled = error.handled;
      mechanismType = error.mechanism;
      currentError = error.source;
    }

    StackTrace? effectiveStackTrace = stackTrace;
    bool isGeneratedStackTrace = false;

    // If it's an Error, try to use its built-in stackTrace
    if (currentError is Error) {
      effectiveStackTrace ??= currentError.stackTrace;
    }

    // If still null or empty, get current stack trace
    if (effectiveStackTrace == null ||
        effectiveStackTrace == StackTrace.empty) {
      effectiveStackTrace = stackTraceProvider?.call() ?? StackTrace.current;
      isGeneratedStackTrace = true; // Flag to remove top PostHog frames
    }

    // Check if we still have an empty stack trace
    final hasValidStackTrace = effectiveStackTrace != StackTrace.empty;

    // Process single exception for now
    final frames = hasValidStackTrace
        ? _parseStackTrace(
            effectiveStackTrace,
            inAppIncludes: inAppIncludes,
            inAppExcludes: inAppExcludes,
            inAppByDefault: inAppByDefault,
            removeTopPostHogFrames: isGeneratedStackTrace,
          )
        : <Map<String, dynamic>>[];

    final errorType = _getExceptionType(currentError);

    // Mark exception as synthetic if:
    // - runtimeType.toString() returned empty/null (fallback to 'Error' type)
    // - Stack trace was generated by PostHog (not from original exception)
    // - No valid stack trace is available
    final isSynthetic =
        errorType == null || isGeneratedStackTrace || !hasValidStackTrace;

    final exceptionData = <String, dynamic>{
      'type': errorType ?? 'Error',
      'mechanism': {
        'handled': handled,
        'synthetic': isSynthetic,
        'type': mechanismType,
      }
    };

    // Add exception message, if available
    final errorMessage = currentError.toString();
    if (errorMessage.isNotEmpty) {
      exceptionData['value'] = errorMessage;
    }

    // Add stacktrace, if any frames are available
    if (frames.isNotEmpty) {
      exceptionData['stacktrace'] = {
        'frames': frames,
        'type': 'raw',
      };
    }

    // Add thread ID, if available
    final threadId = _getCurrentThreadId();
    if (threadId != null) {
      exceptionData['thread_id'] = threadId;
    }

    // Final result, merging system properties with user properties (user properties take precedence)
    final result = <String, dynamic>{
      '\$exception_level': 'error', // Never crashes, so always error
      '\$exception_list': [exceptionData],
      if (properties != null) ...properties,
    };

    return result;
  }

  /// Determines if a stack frame belongs to PostHog SDK (just check package for now)
  static bool _isPostHogFrame(Frame frame) {
    return frame.package == 'posthog_flutter';
  }

  /// Asynchronous gap frame for separating async traces
  static const _asynchronousGapFrame = <String, dynamic>{
    'platform': 'dart',
    'abs_path': '<asynchronous suspension>',
    'in_app': false,
    'synthetic': true
  };

  /// Parses stack trace into PostHog format
  ///
  /// Approach inspired by Sentry's stack trace factory implementation:
  /// https://github.com/getsentry/sentry-dart/blob/a69a51fd1695dd93024be80a50ad05dd990b2b82/packages/dart/lib/src/sentry_stack_trace_factory.dart#L29-L53
  static List<Map<String, dynamic>> _parseStackTrace(
    StackTrace stackTrace, {
    List<String>? inAppIncludes,
    List<String>? inAppExcludes,
    bool inAppByDefault = true,
    bool removeTopPostHogFrames = false,
  }) {
    final chain = Chain.forTrace(stackTrace);
    final frames = <Map<String, dynamic>>[];

    for (final (index, trace) in chain.traces.indexed) {
      bool skipNextPostHogFrame = removeTopPostHogFrames;

      for (final frame in trace.frames) {
        // Skip top PostHog frames?
        if (skipNextPostHogFrame) {
          if (_isPostHogFrame(frame)) {
            continue;
          }
          skipNextPostHogFrame = false;
        }

        final processedFrame = _convertFrameToPostHog(
          frame,
          inAppIncludes: inAppIncludes,
          inAppExcludes: inAppExcludes,
          inAppByDefault: inAppByDefault,
        );
        if (processedFrame != null) {
          frames.add(processedFrame);
        }
      }

      // Add asynchronous gap frame between traces (skipping last trace)
      if (index < chain.traces.length - 1) {
        frames.add(_asynchronousGapFrame);
      }
    }

    return frames;
  }

  /// Converts a Frame from stack_trace package to PostHog format
  static Map<String, dynamic>? _convertFrameToPostHog(
    Frame frame, {
    List<String>? inAppIncludes,
    List<String>? inAppExcludes,
    bool inAppByDefault = true,
  }) {
    final frameData = <String, dynamic>{
      'platform': 'dart',
      'abs_path': _extractAbsolutePath(frame),
      'in_app': _isInAppFrame(
        frame,
        inAppIncludes: inAppIncludes,
        inAppExcludes: inAppExcludes,
        inAppByDefault: inAppByDefault,
      ),
    };

    // add package, if available
    final package = _extractPackage(frame);
    if (package != null && package.isNotEmpty) {
      frameData['package'] = package;
    }

    // add function, if available
    final member = frame.member;
    if (member != null && member.isNotEmpty) {
      frameData['function'] = member;
    }

    // Add filename, if available
    final fileName = _extractFileName(frame);
    if (fileName != null && fileName.isNotEmpty) {
      frameData['filename'] = fileName;
    }

    // Add line number, if available
    final line = frame.line;
    if (line != null && line >= 0) {
      frameData['lineno'] = line;
    }

    // Add column number, if available
    final column = frame.column;
    if (column != null && column >= 0) {
      frameData['colno'] = column;
    }

    return frameData;
  }

  /// Determines if a frame is considered in-app
  static bool _isInAppFrame(
    Frame frame, {
    List<String>? inAppIncludes,
    List<String>? inAppExcludes,
    bool inAppByDefault = true,
  }) {
    final scheme = frame.uri.scheme;

    if (scheme.isEmpty) {
      // Early bail out for unknown schemes
      return inAppByDefault;
    }

    final package = frame.package;
    if (package != null) {
      // 1. Check inAppIncludes first (highest priority)
      if (inAppIncludes != null && inAppIncludes.contains(package)) {
        return true;
      }

      // 2. Check inAppExcludes second
      if (inAppExcludes != null && inAppExcludes.contains(package)) {
        return false;
      }
    }

    // 3. Hardcoded exclusions
    if (frame.isCore) {
      // dart: packages
      return false;
    }

    if (frame.package == 'flutter') {
      // flutter package
      return false;
    }

    // 4. Default fallback
    return inAppByDefault;
  }

  static String? _extractPackage(Frame frame) {
    return frame.package;
  }

  static String? _extractFileName(Frame frame) {
    return frame.uri.pathSegments.isNotEmpty
        ? frame.uri.pathSegments.last
        : null;
  }

  static String _extractAbsolutePath(Frame frame) {
    // For privacy, only return filename for local file paths
    if (frame.uri.scheme != 'dart' &&
        frame.uri.scheme != 'package' &&
        frame.uri.pathSegments.isNotEmpty) {
      return frame.uri.pathSegments.last; // Just filename for privacy
    }

    // For dart: and package: URIs, full path is safe
    return frame.uri.toString();
  }

  /// Gets the current thread ID using isolate-based detection
  static int? _getCurrentThreadId() {
    try {
      // Check if we're in the root isolate (main thread)
      if (isolate_utils.isRootIsolate()) {
        return 'main'.hashCode;
      }

      // For other isolates, use the isolate's debug name
      final isolateName = isolate_utils.getIsolateName();
      if (isolateName != null && isolateName.isNotEmpty) {
        return isolateName.hashCode;
      }

      return null;
    } catch (e) {
      return null;
    }
  }

  static String? _getExceptionType(Object error) {
    // The string is only intended for providing information to a reader while debugging. There is no guaranteed format, the string value returned for a Type instances is entirely implementation dependent.
    final type = error.runtimeType.toString();
    return type.isNotEmpty ? type : null;
  }
}
